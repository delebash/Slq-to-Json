const NearleyParser = require('nearley').Parser;
const NearleyGrammar = require('nearley').Grammar;

const MySQLGrammarRules = require('./mysql/parser/grammar');
const MySQLCompactFormatter = require('./mysql/formatter/compact');
const MySQLJSONSchemaFormatter = require('./mysql/formatter/json-schema');

const {JSONSchemaFormatOptions, JSONSchemaFileOptions} = require('./shared/options');
const utils = require('./shared/utils');

const fs = require('fs');
const {join} = require('path');
const ejs = require('ejs');
const stringifyObject = require('stringify-object');



/**
 * Main Parser class, wraps nearley parser main methods.
 */
class Parser {

    /**
     * Parser constructor.
     * Default dialect is 'mysql'.
     *
     * @param {string} dialect SQL dialect ('mysql' or 'mariadb' currently supported).
     */
    constructor(dialect = 'mysql') {
        if (!dialect || dialect === 'mysql' || dialect === 'mariadb') {
            this.compiledGrammar = NearleyGrammar.fromCompiled(MySQLGrammarRules);
            this.compactFormatter = MySQLCompactFormatter;
            this.jsonSchemaFormatter = MySQLJSONSchemaFormatter;
        } else {
            throw new TypeError(`Unsupported SQL dialect given to parser: '${dialect}. ` +
                `Please provide 'mysql', 'mariadb' or none to use default.`);
        }

        this.resetParser();

        /**
         * Parsed statements.
         * @type {string[]}
         */
        this.statements = [];

        /**
         * Remains of string feed, after last parsed statement.
         */
        this.remains = '';

        /**
         * Whether preparser is currently escaped.
         */
        this.escaped = false;

        /**
         * Current quote char of preparser.
         */
        this.quoted = '';
    }

    /**
     * Feed chunk of string into parser.
     *
     * @param {string} chunk Chunk of string to be parsed.
     * @returns {Parser} Parser class.
     */
    feed(chunk) {
        let i, char, parsed = '';
        let lastStatementIndex = 0;

        for (i = 0; i < chunk.length; i++) {
            char = chunk[i];
            parsed += char;

            if (char === '\\') {
                this.escaped = !this.escaped;
            } else {
                if (!this.escaped && this.isQuoteChar(char)) {
                    if (this.quoted) {
                        if (this.quoted === char) {
                            this.quoted = '';
                        }
                    } else {
                        this.quoted = char;
                    }
                } else if (char === ';' && !this.quoted) {
                    const statement = this.remains + parsed.substr(lastStatementIndex, i + 1);
                    this.statements.push(statement);
                    this.remains = '';
                    lastStatementIndex = i + 1;
                }

                this.escaped = false;
            }
        }

        this.remains += parsed.substr(lastStatementIndex);

        return this;
    }

    /**
     * Recreates NearleyParser using grammar given in constructor.
     *
     * @returns {void}
     */
    resetParser() {
        this.parser = new NearleyParser(this.compiledGrammar);
    }

    /**
     * Checks whether character is a quotation character.
     *
     * @param {string} char Character to be evaluated.
     * @returns {boolean} Whether char is quotation char.
     */
    isQuoteChar(char) {
        return char === '"' || char === "'" || char === '`';
    }
    //******format string
    flatten(obj, path = '') {
        if (!(obj instanceof Object)) return {[path.replace(/\.$/g, '')]:obj};

        return Object.keys(obj).reduce((output, key) => {
            return obj instanceof Array ?
                {...output, ...this.flatten(obj[key], path +  '[' + key + '].')}:
                {...output, ...this.flatten(obj[key], path + key + '.')};
        }, {});
    }
    /**
     * Tidy parser results.
     *
     * @param {any} results Parser results.
     * @returns {any} Tidy results.
     */
    tidy(results) {
        return results[0];
    }

    /**
     * Parser results getter. Will run nearley parser on string fed to this parser.
     *
     * @returns {any} Parsed results.
     */
    get results() {
        let lineCount = 1;
        let statement = this.statements.shift();
        const results = [];

        /**
         * Since we separate the statements, if there is a parse error in a block among
         * several statements in a stream, the parser will throw the error with line
         * 0 counting from the beginning of the statement, not the stream. So we
         * need to catch and correct line count incrementally along the stream.
         *
         * https://github.com/duartealexf/sql-ddl-to-json-schema/issues/20
         */
        try {
            while (statement) {
                this.parser.feed(statement);
                lineCount += (statement.match(/\r\n|\r|\n/g) || []).length;
                results.push(this.tidy(this.parser.results));
                statement = this.statements.shift();

                this.resetParser();
            }
        } catch (e) {
            /**
             * Apply line count correction.
             */
            if (e.message && utils.isString(e.message)) {
                const matches = e.message.match(/^invalid syntax at line (\d+)/);
                if (matches && Array.isArray(matches) && matches.length > 1) {
                    const errorLine = Number(matches[1]);
                    const newCount = lineCount + errorLine - 1;
                    e.message = e.message.replace(/\d+/, newCount);
                }
            }

            /**
             * Reset everything to not affect next feed.
             */
            this.resetParser();
            this.statements = [];
            this.remains = '';
            this.escaped = false;
            this.quoted = '';

            throw e;
        }

        /**
         * Reset remains to not affect next feed.
         */
        this.remains = '';
        this.escaped = false;
        this.quoted = '';

        return {
            id: "MAIN",
            def: results
        };
    }

    /**
     * Formats given parsed JSON to a compact format.
     * If no JSON is given, will use currently parsed SQL.
     *
     * @param {any} json Parsed JSON format (optional).
     * @returns {any[]} Array of tables in compact JSON format.
     */
    toCompactJson(json = null) {
        if (!json) {
            json = this.results;
        }

        return this.compactFormatter.format(json);
    }

    /**
     * Formats parsed SQL to an array of JSON Schema documents,
     * where each item is the JSON Schema of a table. If no
     * tables are given, will use currently parsed SQL.
     *
     * @param {JSONSchemaFormatOptions} options Options available to format as JSON Schema (optional).
     * @param {any[]} tables Array of tables in compact JSON format (optional).
     * @returns {any[]} JSON Schema documents array.
     */
    toJsonSchemaArray(options = new JSONSchemaFormatOptions(), tables = null) {
        if (!tables) {
            tables = this.toCompactJson();
        }

        return this.jsonSchemaFormatter.format(tables, options);
    }



    /**
     * Output JSON Schema files (one for each table) in given output directory for the
     * parsed SQL. If no JSON Schemas array is given, will use currently parsed SQL.
     *
     * @param {string} outputDir Output directory.
     * @param {JSONSchemaFileOptions} options Options object for JSON Schema output to files (optional).
     * @param {any[]} jsonSchemas JSON Schema documents array (optional).
     * @returns {Promise<string[]>} Resolved promise with output file paths.
     */

    toJsonSchemaFiles(outputDir, options = new JSONSchemaFileOptions(), jsonSchemas = null) {
        if (!outputDir) {
            throw new Error('Please provide output directory for JSON Schema files');
        }

        if (!jsonSchemas) {
            jsonSchemas = this.toJsonSchemaArray({
                useRef: options.useRef,
            });
        }


        //******format string

        return Promise.all(
            jsonSchemas.map(schema => {
                return new Promise(resolve => {
                    if (!schema.$id) {
                        throw new Error('No root $id found in schema. It should contain the table name. ' +
                            'If you have modified the JSON Schema, please keep the $id, as it will be the file name.');
                    }
                  // let strSchema = this.flatten(schema)
                    const filename = schema.$id;
                    const filepath = join(outputDir, filename + '.js');

                   // const map = new Map(Object.entries(schema));
                  //   const obj = { foo: 'bar', baz: 42 };
                  //   const map = new Map(Object.entries(obj));
                  //   console.log(map); // Map { foo: "bar", baz: 42 }
                  //
                  //   const tobj = { foo: 'bar', baz: 42 };
                  //   Object.entries(tobj).forEach(([key, value]) => console.log(`${key}: ${value}`)); // "foo: bar", "baz: 42"
                  // //  buildString(schema)
                  //   // Change for use with Feathersjs-plua/generator-feathers-plus
                  //   //Creates schema.json files for use with mysql
                  //   let user = {
                  //       name: "John",
                  //       age: 30
                  //   };

                 //   Object.entrie(schema.properties)
                        //.forEach(function(prop) {console.log(prop + ':' + value)})


             //       const obj = { foo: 'bar', baz: 42 };
                 //   Object.entries(obj).forEach(([key, value]) => console.log(`${key}: ${value}`));

                    // var obj = { a:{}, b:1, c: {d:'test'}};
                    // var obj2 = Object.entries(obj).map((array) => ({ [array[0]]: array[1] }));
                    //
                    // console.log(obj2);
                  //  var result = JSON.parse( schema );
               //   let strJson = JSON.stringify(schema)
               //   var obj = JSON.parse(strJson.replace(/(\{|,)\s*(.+?)\s*:/g, '$1 "$2":'));
                //    a=a.replace(/"(\w+)"\s*:/g, '$1:');
                  const pretty = stringifyObject(schema, {
                    indent: '  ',
                    singleQuotes: false
                  });
                    ejs.renderFile(join(__dirname, './template.ejs'), schema, options, (err, result) => {
                       // locals.f = flatten
                        if (err) {
                            throw err;
                        } else {
                            try {
                                fs.writeFileSync(filepath, result, 'utf8');
                                resolve(filepath);
                            } catch (err) {
                                if (err) {
                                    throw err;
                                }
                            }
                        }
                    });


                    // fs.writeFile(filepath, JSON.stringify(schema, null, options.indent), err => {
                    //   if (err) {
                    //     throw new Error(`Error when trying to write to file ${filepath}: ${JSON.stringify(err, null, 2)}`);
                    //   }
                    //   resolve(filepath);
                    // });
                });
            })
        );
    }

}

module.exports = Parser;
